#!/usr/bin/env python3

"""HomeLink - WireGuard VPN management tool."""

from __future__ import annotations

import argparse
import contextlib
import json
import logging
import os
import signal
import socket
import subprocess
import sys
import threading
import time
from collections import deque
from datetime import datetime, timedelta, timezone
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from types import FrameType


# Constants
SOCKET_PATH = "/run/homelink/monitor.sock"
DNS_SERVERS = ["8.8.8.8", "1.1.1.1"]
VIRTUAL_INTERFACE_PREFIXES = (
    "wg",
    "tun",
    "tap",
    "veth",
    "docker",
    "br-",
    "lo",
    "virbr",
    "vmbr",
)


class ConsensusTracker:
    """Track values in a sliding window and return consensus when all values agree."""

    def __init__(self, history_size: int) -> None:
        """Initialize tracker with specified history size."""
        self.history: deque[Any] = deque(maxlen=history_size)

    def add(self, current_value: Any) -> None:
        """Add current value to the history."""
        self.history.append(current_value)

    def get(self) -> Any | None:
        """Get current consensus without updating history."""
        if len(self.history) < self.history.maxlen:
            return None
        first_value = self.history[0]
        if all(val == first_value for val in self.history):
            return first_value
        return None


def run_command(
    cmd: list[str],
    timeout: int = 5,
) -> subprocess.CompletedProcess[str] | None:
    """Run a command and return result, or None on timeout."""
    try:
        return subprocess.run(
            cmd,
            check=False,
            capture_output=True,
            text=True,
            timeout=timeout,
        )
    except subprocess.TimeoutExpired:
        return None


class HomeLinkMonitor:
    """WireGuard VPN monitor."""

    def __init__(self) -> None:
        """Initialize the HomeLink monitor."""
        # Configuration from environment
        self.interface = os.getenv("HOMELINK_INTERFACE", "wg0")
        self.home_router = os.getenv("HOMELINK_HOME_ROUTER", "192.168.114.1")
        self.check_interval = int(os.getenv("HOMELINK_CHECK_INTERVAL", "10"))
        self.internet_history_size = int(
            os.getenv("HOMELINK_INTERNET_HISTORY_SIZE", "3"),
        )
        self.ping_timeout = int(os.getenv("HOMELINK_PING_TIMEOUT", "3"))
        self.resume_delay = int(os.getenv("HOMELINK_RESUME_DELAY", "30"))

        # State tracking
        self.state = {
            "location": "remote",
            "internet_tracker": ConsensusTracker(self.internet_history_size),
            "vpn": "down",
            "vpn_control_signal": "noop",
            "next_check_at": None,
        }
        self.running = True
        self.socket_server = None
        self.logger = self._setup_logging()

    def _setup_logging(self) -> logging.Logger:
        """Set up structured logging for systemd journal."""
        log_level = os.getenv("HOMELINK_LOG_LEVEL", "INFO").upper()
        logging.basicConfig(
            level=getattr(logging, log_level, logging.INFO),
            format="%(message)s",
            handlers=[logging.StreamHandler(sys.stdout)],
        )
        return logging.getLogger("homelink-monitor")

    def _ping(self, host: str, interface: str | None = None) -> bool:
        """Ping a host, optionally through specific interface."""
        cmd = ["ping", "-c", "1", "-W", str(self.ping_timeout)]
        if interface:
            cmd.extend(["-I", interface])
        cmd.append(host)

        try:
            result = subprocess.run(
                cmd,
                check=False,
                capture_output=True,
                timeout=self.ping_timeout + 2,
            )
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
        else:
            return result.returncode == 0

    def _systemctl(self, action: str) -> bool:
        """Execute systemctl command."""
        try:
            subprocess.run(
                ["systemctl", action, "homelink.service"],  # noqa: S607
                timeout=30,
                check=True,
            )
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired):
            self.logger.exception("Failed to %s homelink service", action)
            return False
        else:
            return True

    def _get_physical_interfaces(self) -> list[str]:
        """Get list of physical network interfaces (excluding virtual ones)."""
        result = run_command(["ip", "link", "show"])
        if not result:
            return []

        interfaces = []

        for line in result.stdout.split("\n"):
            if ": " in line and "state UP" in line:
                # Extract interface name from lines like "2: eth0: <BROADCAST,...>"
                parts = line.split(": ")
                if len(parts) >= 2:  # noqa: PLR2004
                    iface_name = parts[1].split("@")[
                        0
                    ]  # Handle vlan interfaces like eth0@if2
                    # Exclude virtual interfaces and our WG interface
                    if (
                        not iface_name.startswith(VIRTUAL_INTERFACE_PREFIXES)
                        and iface_name != self.interface
                    ):
                        interfaces.append(iface_name)

        return interfaces

    def _check_vpn(self) -> str:
        """Check VPN status: down, degraded, or up."""
        # Check if WireGuard interface exists
        wg_result = run_command(["ip", "link", "show", self.interface])
        if not wg_result or wg_result.returncode != 0:
            return "down"

        # Interface is up, now check tunnel health
        # 1. Try to ping home router
        if self._ping(self.home_router):
            return "up"

        # 2. Check if we have a route through the WG interface
        result = run_command(["ip", "route", "show", "dev", self.interface])
        if result and result.stdout.strip():
            # If we have routes through WG interface, assume it's working
            # This is more reliable than ping which might be blocked
            return "up"

        # 3. Check if the interface has an IP assigned
        result = run_command(["ip", "addr", "show", self.interface])
        if result and "inet " in result.stdout:
            return "up"

        # Interface exists but tunnel is broken
        return "degraded"

    def _check_location(self) -> bool:
        """Check if we're at home right now (instantaneous check)."""
        # Get default route through physical interfaces only
        physical_ifaces = self._get_physical_interfaces()

        for iface in physical_ifaces:
            # Check if this interface has a default route via home router
            result = run_command(["ip", "route", "show", "default", "dev", iface])
            if result and self.home_router in result.stdout:
                return True

        return False

    def _update_network_state(self) -> None:
        """Update network state by checking instantaneous values and feeding to trackers."""
        # Check instantaneous values
        location_is_home = self._check_location()
        internet_working = any(self._ping(target) for target in DNS_SERVERS)
        vpn_status = self._check_vpn()

        # Update trackers
        self.state["internet_tracker"].add(internet_working)

        # Set state values
        self.state["location"] = "home" if location_is_home else "remote"
        self.state["vpn"] = vpn_status

    def _determine_control_signal(self) -> str:
        """Determine VPN control signal using 3-variable model."""
        location = self.state["location"]
        vpn = self.state["vpn"]
        internet_consensus = self.state["internet_tracker"].get()

        if location == "home":
            # At home, VPN should be down
            return "down" if vpn != "down" else "noop"

        if internet_consensus is False:
            # No internet consensus (consistently down), VPN should be down
            return "down" if vpn != "down" else "noop"

        if internet_consensus is None:
            # No internet consensus (uncertain), maintain current state
            return "noop"

        # Remote with working internet (internet_consensus is True)
        if vpn == "down":
            return "up"
        if vpn == "degraded":
            return "restart"
        return "noop"

    def update_and_act(self) -> None:
        """Update state and take action - main logic loop."""
        old_signal = self.state["vpn_control_signal"]

        # Check for resume from suspend by detecting timing gap
        now = datetime.now(timezone.utc)
        if self.state["next_check_at"] and now > self.state[
            "next_check_at"
        ] + timedelta(seconds=self.check_interval * 2):
            self.logger.info(
                "System resume detected, delaying next check by %ds for stabilization",
                self.resume_delay,
            )
            self.state["next_check_at"] = now + timedelta(
                seconds=self.resume_delay,
            )
            return

        # Set next check time for normal operation
        self.state["next_check_at"] = now + timedelta(seconds=self.check_interval)

        # Update network state (includes connectivity history update)
        self._update_network_state()

        # Determine what we want
        control_signal = self._determine_control_signal()
        self.state["vpn_control_signal"] = control_signal

        # Log control signal changes
        if old_signal != control_signal:
            self.logger.info(
                "Control signal change: %s -> %s",
                old_signal,
                control_signal,
            )

        # Take action based on control signal
        location, internet, vpn = (
            self.state["location"],
            self.state["internet_tracker"].get(),
            self.state["vpn"],
        )
        internet = "up" if internet else ("uncertain" if internet is None else "down")

        if control_signal == "down" and vpn != "down":
            self.logger.info(
                "Bringing down HomeLink (location=%s, internet=%s)",
                location,
                internet,
            )
            self._systemctl("stop")
        elif control_signal == "up" and vpn == "down":
            self.logger.info(
                "Starting HomeLink (location=%s, internet=%s)",
                location,
                internet,
            )
            self._systemctl("start")
        elif control_signal == "restart":
            self.logger.warning("Restarting HomeLink (vpn=%s)", vpn)
            self._systemctl("restart")
        elif control_signal == "noop":
            self.logger.debug(
                "No VPN action needed (location=%s, internet=%s, vpn=%s)",
                location,
                internet,
                vpn,
            )

    def get_status(self) -> dict[str, str | bool]:
        """Get current status for API."""
        # Get internet status from tracker
        internet_consensus = self.state["internet_tracker"].get()
        if internet_consensus is None:
            internet_status = "uncertain"
        elif internet_consensus:
            internet_status = "up"
        else:
            internet_status = "down"

        # Create status dict with computed fields, excluding internal objects
        status = {
            k: v for k, v in self.state.items() if not isinstance(v, ConsensusTracker)
        }
        status["internet"] = internet_status

        # Format next_check_at as ISO string if available
        if self.state["next_check_at"]:
            status["next_check_at"] = self.state["next_check_at"].isoformat()

        return status

    def _handle_socket_client(self, client_socket: socket.socket) -> None:
        """Handle socket client - always return status."""
        try:
            client_socket.settimeout(5.0)
            client_socket.recv(1024)  # Read and ignore request
            response = self.get_status()
            client_socket.send((json.dumps(response) + "\n").encode())
        except socket.timeout:
            self.logger.debug("Socket client timeout")
        except Exception:
            self.logger.exception("Error handling socket client")
        finally:
            client_socket.close()

    def _setup_socket_server(self) -> None:
        """Set up Unix domain socket server."""
        socket_dir = Path(SOCKET_PATH).parent
        socket_dir.mkdir(parents=True, exist_ok=True)

        with contextlib.suppress(FileNotFoundError):
            Path(SOCKET_PATH).unlink()

        self.socket_server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.socket_server.bind(SOCKET_PATH)
        self.socket_server.listen(5)
        self.socket_server.settimeout(1.0)
        Path(SOCKET_PATH).chmod(0o666)

        self.logger.info("Socket server listening on %s", SOCKET_PATH)

    def _socket_server_loop(self) -> None:
        """Run socket server loop."""
        while self.running:
            try:
                self.socket_server.settimeout(1.0)
                client_socket, _ = self.socket_server.accept()
                threading.Thread(
                    target=self._handle_socket_client,
                    args=(client_socket,),
                    daemon=True,
                ).start()
            except socket.timeout:  # noqa: PERF203
                continue
            except Exception:
                if self.running:
                    self.logger.exception("Socket server error")

    def _signal_handler(self, signum: int, _frame: FrameType | None) -> None:
        """Handle shutdown signals."""
        signal_names = {signal.SIGTERM: "SIGTERM", signal.SIGINT: "SIGINT"}
        self.logger.info(
            "Received %s, shutting down...",
            signal_names.get(signum, signum),
        )
        self.running = False

    def cleanup(self) -> None:
        """Clean up resources."""
        if self.socket_server:
            self.socket_server.close()
        with contextlib.suppress(FileNotFoundError):
            Path(SOCKET_PATH).unlink()

    def run(self) -> None:
        """Run main daemon loop."""
        # Setup signal handlers
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)

        self.logger.info("HomeLink Monitor daemon starting")

        try:
            self._setup_socket_server()
            threading.Thread(target=self._socket_server_loop, daemon=True).start()

            # Main monitoring loop
            while self.running:
                try:
                    self.update_and_act()
                    now = datetime.now(timezone.utc)
                    sleep_duration = (self.state["next_check_at"] - now).total_seconds()
                    if sleep_duration > 0:
                        time.sleep(sleep_duration)

                except KeyboardInterrupt:  # noqa: PERF203
                    break
                except Exception:
                    self.logger.exception("Error in main loop")
                    time.sleep(self.check_interval)

        finally:
            self.cleanup()
            self.logger.info("HomeLink Monitor daemon stopped")


def cmd_monitor() -> None:
    """Run HomeLink monitor daemon."""
    if os.geteuid() != 0:
        sys.stderr.write(
            "Warning: HomeLink Monitor should typically run as root "
            "to manage systemd services\n",
        )
    HomeLinkMonitor().run()


def cmd_status(*, json_output: bool = False) -> int:  # noqa: C901
    """Get HomeLink status from socket."""
    try:
        with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
            sock.settimeout(5)
            sock.connect(SOCKET_PATH)
            sock.send(b"status")

            response = ""
            while True:
                chunk = sock.recv(4096).decode()
                if not chunk:
                    break
                response += chunk
                if response.endswith("\n"):
                    break

            status = json.loads(response.strip())
    except socket.timeout:
        status = {"error": "Timeout connecting to daemon"}
    except FileNotFoundError:
        status = {"error": f"Socket not found: {SOCKET_PATH}"}
    except ConnectionRefusedError:
        status = {"error": "Daemon not running"}
    except json.JSONDecodeError:
        status = {"error": "Invalid JSON response"}
    except Exception as e:  # noqa: BLE001
        status = {"error": f"Connection error: {e!s}"}

    if json_output:
        print(json.dumps(status, indent=2))
        return 1 if "error" in status else 0

    if "error" in status:
        print(f"Error: {status['error']}")
        return 1

    lines = [
        f"Location: {status.get('location', 'unknown')}",
        f"Internet: {status.get('internet', 'unknown')}",
        f"VPN: {status.get('vpn', 'unknown')}",
        f"VPN Control Signal: {status.get('vpn_control_signal', 'unknown')}",
    ]

    if "next_check_at" in status:
        try:
            next_check = datetime.fromisoformat(
                status["next_check_at"].replace("Z", "+00:00"),
            )
            seconds_until = int(
                (next_check - datetime.now(timezone.utc)).total_seconds(),
            )
            next_text = (
                f"in {seconds_until} seconds" if seconds_until > 0 else "overdue"
            )
            lines.append(f"Next check: {next_text}")
        except (ValueError, TypeError):
            lines.append(f"Next check: {status['next_check_at']}")

    print("\n".join(lines))
    return 0


def cmd_logs() -> int:
    """Tail HomeLink logs."""
    with contextlib.suppress(KeyboardInterrupt):
        subprocess.run(
            ["journalctl", "-u", "homelink-monitor.service", "-f"],  # noqa: S607
            check=False,
        )
    return 0


def main() -> int:
    """Parse arguments and run the appropriate command."""
    parser = argparse.ArgumentParser(
        prog="homelink",
        description="HomeLink - WireGuard VPN management tool",
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    subparsers.add_parser("monitor", help="Start HomeLink monitor daemon")
    status_parser = subparsers.add_parser(
        "status",
        help="Show detailed HomeLink status",
    )
    status_parser.add_argument(
        "--json",
        action="store_true",
        help="Output raw JSON data",
    )
    subparsers.add_parser("logs", help="Tail HomeLink monitor logs")

    args = parser.parse_args()

    if args.command == "monitor":
        cmd_monitor()
        return 0
    if args.command == "status":
        return cmd_status(json_output=args.json)
    if args.command == "logs":
        return cmd_logs()
    parser.print_help()
    return 1


if __name__ == "__main__":
    sys.exit(main())

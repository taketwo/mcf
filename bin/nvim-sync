#!/usr/bin/env bash

# Define available operations and targets
declare -a operations=("restore" "update" "commit")
declare -a targets=("plugins")
declare -A valid_operations
declare -A valid_targets
for operation in "${operations[@]}"; do
  valid_operations[$operation]=1
done
for target in "${targets[@]}"; do
  valid_targets[$target]=1
done

LOCK_REPO_NAME="mcf-nvim-lock"
LOCK_REPO_HTTPS_URI="https://gitlab.com/taketwo/$LOCK_REPO_NAME.git"
LOCK_REPO_GIT_URI="git@gitlab.com:taketwo/$LOCK_REPO_NAME.git"
LOCK_REPO_PATH="$MCF/external/$LOCK_REPO_NAME"
LAZY_LOCK_FILE_NAME="lazy-lock.json"
LAZY_LOCK_FILE_PATH_LOCAL="$MCF/misc/packages/neovim/config/$LAZY_LOCK_FILE_NAME"
LAZY_LOCK_FILE_PATH_REMOTE="$LOCK_REPO_PATH/$LAZY_LOCK_FILE_NAME"

# Restore the state of Neovim plugins according to the latest remote lock file
function restore_plugins() {
  echo "Fetching the latest lock file from the remote repository"
  if ! git -C "$LOCK_REPO_PATH" fetch; then
    echo "Git fetch failed, aborting"
    exit 1
  fi
  git -C "$LOCK_REPO_PATH" reset --hard origin/main
  retries_left=3
  until [ $retries_left -le 0 ]; do
    echo "Restoring the state of Neovim plugins"
    cp "$LAZY_LOCK_FILE_PATH_REMOTE" "$LAZY_LOCK_FILE_PATH_LOCAL"
    nvim --headless "+Lazy! restore" "+TSUpdateSync" +qa
    echo "" # TSUpdateSync always prints a message without newline, so we add one
    if diff --brief "$LAZY_LOCK_FILE_PATH_REMOTE" "$LAZY_LOCK_FILE_PATH_LOCAL" >/dev/null; then
      echo "Restoration succeeded"
      break
    else
      retries_left=$((retries_left - 1))
      if [ $retries_left -gt 0 ]; then
        echo "Lock file has changed while executing restore command, retrying"
      else
        echo "Restoration failed after 3 retries"
        echo "List of plugins that failed to be updated:"
        diff --unchanged-line-format="" --old-line-format="" --new-line-format="%L" "$LAZY_LOCK_FILE_PATH_REMOTE" "$LAZY_LOCK_FILE_PATH_LOCAL" | sed 's/:.*//' | sed 's/"//g'
        exit 2
      fi
    fi
  done
}

# Update Neovim plugins
function update_plugins() {
  echo "Launching Neovim to update plugins"
  nvim -c 'autocmd User VeryLazy Lazy check'
}

# Commit changes in the local lock file and push to the remote repository
function commit_plugins() {
  cp "$LAZY_LOCK_FILE_PATH_LOCAL" "$LAZY_LOCK_FILE_PATH_REMOTE"
  # Check if the lock file has changed
  if ! git -C "$LOCK_REPO_PATH" diff --quiet "$LAZY_LOCK_FILE_NAME"; then
    # Pushing will work only if the remote is configured with SSH address
    if [[ "$(git -C "$LOCK_REPO_PATH" remote get-url origin)" != "$LOCK_REPO_GIT_URI" ]]; then
      echo "Updating remote URI to use SSH authorization"
      git -C "$LOCK_REPO_PATH" remote set-url origin $LOCK_REPO_GIT_URI
    fi
    echo "Lock file has changed, committing and pushing changes"
    git -C "$LOCK_REPO_PATH" add "$LAZY_LOCK_FILE_NAME"
    git -C "$LOCK_REPO_PATH" commit -m "Update $LAZY_LOCK_FILE_NAME" -m "Host: $(hostname -s)"
    git -C "$LOCK_REPO_PATH" push --force
  else
    echo "Lock file has not changed, nothing to commit"
  fi
}

# Clone or pull the external repository
if [ ! -d "$LOCK_REPO_PATH" ]; then
  echo "Lock repository not found, cloning"
  git clone "$LOCK_REPO_HTTPS_URI" "$LOCK_REPO_PATH"
else
  echo "Pulling latest commits in lock repository"
  git -C "$LOCK_REPO_PATH" pull
fi

# Parse and validate the input arguments
declare -a execution_plan
current_operation=""
current_target=""

for arg in "$@"; do
  if [[ $arg == "--dry-run" ]]; then
    dry_run_mode=1
    continue
  fi
  if [[ ${valid_operations[$arg]} ]]; then
    if [[ -n $current_operation && -z $current_target ]]; then
      # Previous operation applies to all targets
      for target in "${targets[@]}"; do
        execution_plan+=("$current_operation $target")
      done
    fi
    current_operation=$arg
    current_target=""
  elif [[ ${valid_targets[$arg]} ]]; then
    if [[ -n $current_operation ]]; then
      execution_plan+=("$current_operation $arg")
      current_target=$arg
    else
      echo "Error: target '$arg' specified without an operation"
      exit 1
    fi
  else
    echo "Error: invalid operation or target '$arg'"
    exit 1
  fi
done

# If the last operation had no targets, apply it to all targets
if [[ -n $current_operation && -z $current_target ]]; then
  for target in "${targets[@]}"; do
    execution_plan+=("$current_operation $target")
  done
fi

# Default behavior if no arguments are provided
if [ ${#execution_plan[@]} -eq 0 ]; then
  for operation in "${operations[@]}"; do
    for target in "${targets[@]}"; do
      execution_plan+=("$operation $target")
    done
  done
fi

# Dry-run output: show the final execution plan and exit
if [[ $dry_run_mode -eq 1 ]]; then
  echo "Execution plan:"
  for operation_target in "${execution_plan[@]}"; do
    echo " - $operation_target"
  done
  exit 0
fi

# Execute the plan
for operation_target in "${execution_plan[@]}"; do
  IFS=' ' read -r operation target <<<"$operation_target"
  func_name="${operation}_${target}"
  if declare -f "$func_name" >/dev/null; then
    "$func_name"
  else
    echo "Error: unsupported operation/target combination: $operation $target"
    exit 1
  fi
done
